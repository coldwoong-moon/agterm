//! AgTerm - AI Agent Terminal
//!
//! Native GPU-accelerated terminal emulator with AI agent orchestration.
//! Inspired by Warp terminal's modern block-based interface.

use iced::keyboard::{self, Key, Modifiers};
use iced::widget::text_input::Id as TextInputId;
use iced::widget::{button, column, container, row, text, text_input, Space};
use iced::{Alignment, Border, Color, Element, Font, Length, Subscription, Task};
use std::sync::Arc;
use std::time::{Duration, Instant};

mod debug;
mod logging;
mod terminal;
mod terminal_canvas;

use debug::{DebugPanel, DebugPanelMessage};
use logging::{LogBuffer, LoggingConfig};
use terminal_canvas::{CursorState, CursorStyle, TerminalCanvas, TerminalCanvasState};

use terminal::pty::PtyManager;
use terminal::screen::{Cell, TerminalScreen};

// ============================================================================
// Font Configuration - Embedded D2Coding for Korean/CJK support
// ============================================================================

/// D2Coding font bytes (Korean monospace font by Naver)
const D2CODING_FONT: &[u8] = include_bytes!("../assets/fonts/D2Coding.ttf");

/// Monospace font with Korean/CJK support
const MONO_FONT: Font = Font::with_name("D2Coding");

// ============================================================================
// Warp-inspired Dark Theme Colors
// ============================================================================

mod theme {
    use iced::Color;

    // Background colors
    pub const BG_PRIMARY: Color = Color::from_rgb(0.09, 0.09, 0.11); // #17171c
    pub const BG_SECONDARY: Color = Color::from_rgb(0.12, 0.12, 0.15); // #1e1e26
    #[allow(dead_code)]
    pub const BG_BLOCK: Color = Color::from_rgb(0.14, 0.14, 0.18); // #242430
    pub const BG_BLOCK_HOVER: Color = Color::from_rgb(0.18, 0.18, 0.22); // #2d2d38
    #[allow(dead_code)]
    pub const BG_INPUT: Color = Color::from_rgb(0.11, 0.11, 0.14); // #1c1c24

    // Text colors
    pub const TEXT_PRIMARY: Color = Color::from_rgb(0.93, 0.93, 0.95); // #edeff2
    pub const TEXT_SECONDARY: Color = Color::from_rgb(0.6, 0.62, 0.68); // #999ead
    pub const TEXT_MUTED: Color = Color::from_rgb(0.45, 0.47, 0.52); // #737885

    // Accent colors
    #[allow(dead_code)]
    pub const ACCENT_BLUE: Color = Color::from_rgb(0.36, 0.54, 0.98); // #5c8afa
    pub const ACCENT_GREEN: Color = Color::from_rgb(0.35, 0.78, 0.55); // #59c78c
    #[allow(dead_code)]
    pub const ACCENT_YELLOW: Color = Color::from_rgb(0.95, 0.77, 0.36); // #f2c55c
    #[allow(dead_code)]
    pub const ACCENT_RED: Color = Color::from_rgb(0.92, 0.39, 0.45); // #eb6473

    // UI elements
    pub const BORDER: Color = Color::from_rgb(0.22, 0.22, 0.28); // #383847
    pub const TAB_ACTIVE: Color = Color::from_rgb(0.36, 0.54, 0.98); // #5c8afa

    // Prompt symbol (may be used in future features)
    #[allow(dead_code)]
    pub const PROMPT: Color = Color::from_rgb(0.55, 0.36, 0.98); // #8c5cfa (purple)

    // ANSI colors (standard 16-color palette) - May be used for ANSI parsing in future
    #[allow(dead_code)]
    pub const ANSI_BLACK: Color = Color::from_rgb(0.0, 0.0, 0.0);
    #[allow(dead_code)]
    pub const ANSI_RED: Color = Color::from_rgb(0.8, 0.2, 0.2);
    #[allow(dead_code)]
    pub const ANSI_GREEN: Color = Color::from_rgb(0.2, 0.8, 0.2);
    #[allow(dead_code)]
    pub const ANSI_YELLOW: Color = Color::from_rgb(0.8, 0.8, 0.2);
    #[allow(dead_code)]
    pub const ANSI_BLUE: Color = Color::from_rgb(0.2, 0.2, 0.8);
    #[allow(dead_code)]
    pub const ANSI_MAGENTA: Color = Color::from_rgb(0.8, 0.2, 0.8);
    #[allow(dead_code)]
    pub const ANSI_CYAN: Color = Color::from_rgb(0.2, 0.8, 0.8);
    #[allow(dead_code)]
    pub const ANSI_WHITE: Color = Color::from_rgb(0.8, 0.8, 0.8);
    // Bright variants
    #[allow(dead_code)]
    pub const ANSI_BRIGHT_BLACK: Color = Color::from_rgb(0.5, 0.5, 0.5);
    #[allow(dead_code)]
    pub const ANSI_BRIGHT_RED: Color = Color::from_rgb(1.0, 0.3, 0.3);
    #[allow(dead_code)]
    pub const ANSI_BRIGHT_GREEN: Color = Color::from_rgb(0.3, 1.0, 0.3);
    #[allow(dead_code)]
    pub const ANSI_BRIGHT_YELLOW: Color = Color::from_rgb(1.0, 1.0, 0.3);
    #[allow(dead_code)]
    pub const ANSI_BRIGHT_BLUE: Color = Color::from_rgb(0.3, 0.3, 1.0);
    #[allow(dead_code)]
    pub const ANSI_BRIGHT_MAGENTA: Color = Color::from_rgb(1.0, 0.3, 1.0);
    #[allow(dead_code)]
    pub const ANSI_BRIGHT_CYAN: Color = Color::from_rgb(0.3, 1.0, 1.0);
    #[allow(dead_code)]
    pub const ANSI_BRIGHT_WHITE: Color = Color::from_rgb(1.0, 1.0, 1.0);

    // ============================================================================
    // Reusable Style Functions
    // ============================================================================

    use iced::widget::container;
    use iced::Border;

    /// Container style for status bar
    pub fn status_bar_style(_theme: &iced::Theme) -> container::Style {
        container::Style {
            background: Some(BG_PRIMARY.into()),
            border: Border {
                color: BORDER,
                width: 1.0,
                radius: 0.0.into(),
            },
            ..Default::default()
        }
    }

    /// Container style for primary background
    pub fn primary_background_style(_theme: &iced::Theme) -> container::Style {
        container::Style {
            background: Some(BG_PRIMARY.into()),
            ..Default::default()
        }
    }
}

// ============================================================================
// ANSI Color Parsing
// ============================================================================

/// A styled text span with optional color
#[derive(Clone, Debug)]
#[allow(dead_code)]
pub struct StyledSpan {
    pub text: String,
    pub color: Option<Color>,
    pub bold: bool,
}

/// Convert terminal cells to styled spans
fn cells_to_styled_spans(cells: &[Cell]) -> Vec<StyledSpan> {
    let mut spans = Vec::new();
    let mut current_text = String::new();
    let mut current_color: Option<Color> = None;
    let mut current_bold = false;

    for cell in cells {
        let color = if let Some(fg) = &cell.fg {
            Some(fg.to_color())
        } else {
            None
        };

        // If color or bold changes, push current span and start new one
        if color != current_color || cell.bold != current_bold {
            if !current_text.is_empty() {
                spans.push(StyledSpan {
                    text: std::mem::take(&mut current_text),
                    color: current_color,
                    bold: current_bold,
                });
            }
            current_color = color;
            current_bold = cell.bold;
        }

        current_text.push(cell.c);
    }

    // Push final span
    if !current_text.is_empty() {
        spans.push(StyledSpan {
            text: current_text,
            color: current_color,
            bold: current_bold,
        });
    }

    spans
}

/// Global log buffer for debug panel (initialized once at startup)
static LOG_BUFFER: std::sync::OnceLock<LogBuffer> = std::sync::OnceLock::new();

fn main() -> iced::Result {
    // Initialize logging system
    let logging_config = LoggingConfig::default();
    let log_buffer = logging::init_logging(&logging_config);

    // Store log buffer globally for access by DebugPanel
    LOG_BUFFER
        .set(log_buffer)
        .expect("LOG_BUFFER already initialized");

    tracing::info!("AgTerm starting");

    iced::application("AgTerm - AI Agent Terminal", AgTerm::update, AgTerm::view)
        .subscription(AgTerm::subscription)
        .font(D2CODING_FONT)
        .run()
}

/// Raw mode input field ID for IME support
fn raw_input_id() -> TextInputId {
    TextInputId::new("raw_terminal_input")
}

/// Main application state
struct AgTerm {
    tabs: Vec<TerminalTab>,
    active_tab: usize,
    pty_manager: Arc<PtyManager>,
    next_tab_id: usize,
    startup_focus_count: u8,
    /// Debug panel state
    debug_panel: DebugPanel,
    /// Last time PTY activity was detected (for dynamic tick optimization)
    last_pty_activity: Instant,
    /// Last cursor blink toggle time
    last_cursor_blink: Instant,
    /// Font size (8.0 ~ 24.0)
    font_size: f32,
}

impl Default for AgTerm {
    fn default() -> Self {
        tracing::debug!("Initializing AgTerm application");
        let pty_manager = Arc::new(PtyManager::new());
        let session_result = pty_manager.create_session(24, 80);
        let cwd = std::env::current_dir()
            .map(|p| p.display().to_string())
            .unwrap_or_else(|_| "~".to_string());

        let (session_id, error_message) = match session_result {
            Ok(id) => {
                tracing::info!(session_id = %id, "Initial PTY session created");
                (Some(id), None)
            }
            Err(e) => {
                tracing::error!(error = %e, "Failed to create initial PTY session");
                (None, Some(format!("Failed to create PTY session: {}", e)))
            }
        };

        let tab = TerminalTab {
            id: 0,
            session_id,
            raw_input: String::new(),
            input: String::new(),
            cwd,
            error_message,
            history: Vec::new(),
            history_index: None,
            history_temp_input: String::new(),
            mode: TerminalMode::Raw, // Default to Raw mode for interactive apps
            parsed_line_cache: Vec::new(),
            canvas_state: TerminalCanvasState::new(),
            content_version: 0,
            screen: TerminalScreen::new(80, 24),
            cursor_blink_on: true,
        };

        let mut debug_panel = DebugPanel::new();
        // Connect log buffer to debug panel
        if let Some(log_buffer) = LOG_BUFFER.get() {
            debug_panel.set_log_buffer(log_buffer.clone());
        }

        tracing::info!("AgTerm application initialized");
        Self {
            tabs: vec![tab],
            active_tab: 0,
            pty_manager,
            next_tab_id: 1,
            startup_focus_count: 10,
            debug_panel,
            last_pty_activity: Instant::now(),
            last_cursor_blink: Instant::now(),
            font_size: 14.0,
        }
    }
}

/// A single terminal tab with block-based output
struct TerminalTab {
    #[allow(dead_code)]
    id: usize,
    session_id: Option<uuid::Uuid>,
    raw_input: String, // Input buffer for Raw mode (IME support)
    #[allow(dead_code)]
    input: String,
    #[allow(dead_code)]
    cwd: String, // Current working directory display
    #[allow(dead_code)]
    error_message: Option<String>, // PTY error message if creation failed
    // Command history
    #[allow(dead_code)]
    history: Vec<String>,
    #[allow(dead_code)]
    history_index: Option<usize>, // Current position in history (None = not browsing)
    #[allow(dead_code)]
    history_temp_input: String, // Temporary storage for current input when browsing
    // Terminal mode
    mode: TerminalMode,
    // ANSI parsing cache for Raw mode
    /// Cached parsed lines for Raw mode (line index -> parsed spans)
    parsed_line_cache: Vec<Vec<StyledSpan>>,
    // Canvas state for virtual scrolling
    #[allow(dead_code)]
    canvas_state: TerminalCanvasState,
    /// Content version for cache invalidation
    content_version: u64,
    /// Terminal screen buffer with VTE parser
    screen: TerminalScreen,
    /// Cursor blink state
    cursor_blink_on: bool,
}

/// Terminal input mode
#[derive(Debug, Clone, Copy, PartialEq, Default)]
enum TerminalMode {
    /// Raw mode: all key input goes directly to PTY (full streaming terminal)
    #[default]
    Raw,
}

/// Signal types for terminal control
#[derive(Debug, Clone, Copy)]
enum SignalType {
    Interrupt, // Ctrl+C (0x03)
    EOF,       // Ctrl+D (0x04)
    Suspend,   // Ctrl+Z (0x1A)
}

impl SignalType {
    /// Convert signal type to its corresponding byte value
    fn as_byte(self) -> u8 {
        match self {
            SignalType::Interrupt => 0x03, // Ctrl+C
            SignalType::EOF => 0x04,       // Ctrl+D
            SignalType::Suspend => 0x1A,   // Ctrl+Z
        }
    }
}

#[derive(Debug, Clone)]
enum Message {
    // Tab management
    NewTab,
    CloseTab(usize),
    CloseCurrentTab,
    SelectTab(usize),
    NextTab,
    PrevTab,

    // Raw input (Raw mode)
    RawInput(String),
    RawInputChanged(String),
    RawInputSubmit,

    // Keyboard events
    KeyPressed(Key, Modifiers),

    // Signal sending
    SendSignal(SignalType),

    // Clipboard
    ClipboardContent(Option<String>),

    // Window resize
    WindowResized {
        width: u32,
        height: u32,
    },

    // Tick for PTY polling
    Tick,

    // Debug panel
    ToggleDebugPanel,
    #[allow(dead_code)]
    DebugPanelMessage(DebugPanelMessage),

    // Font size adjustment
    IncreaseFontSize,
    DecreaseFontSize,
    ResetFontSize,
}

impl AgTerm {
    /// Get the current shell name (e.g., "zsh", "bash")
    fn get_shell_name(&self) -> String {
        std::env::var("SHELL")
            .ok()
            .and_then(|path| {
                std::path::Path::new(&path)
                    .file_name()
                    .and_then(|name| name.to_str())
                    .map(|s| s.to_string())
            })
            .unwrap_or_else(|| "shell".to_string())
    }

    fn update(&mut self, message: Message) -> Task<Message> {
        match message {
            Message::NewTab => {
                let id = self.next_tab_id;
                self.next_tab_id += 1;

                let session_result = self.pty_manager.create_session(24, 80);
                let cwd = std::env::current_dir()
                    .map(|p| p.display().to_string())
                    .unwrap_or_else(|_| "~".to_string());

                let (session_id, error_message) = match session_result {
                    Ok(id) => (Some(id), None),
                    Err(e) => (None, Some(format!("Failed to create PTY session: {}", e))),
                };

                let tab = TerminalTab {
                    id,
                    session_id,
                    raw_input: String::new(),
                    input: String::new(),
                    cwd,
                    error_message,
                    history: Vec::new(),
                    history_index: None,
                    history_temp_input: String::new(),
                    mode: TerminalMode::Raw,
                    parsed_line_cache: Vec::new(),
                    canvas_state: TerminalCanvasState::new(),
                    content_version: 0,
                    screen: TerminalScreen::new(80, 24),
                    cursor_blink_on: true,
                };
                self.tabs.push(tab);
                self.active_tab = self.tabs.len() - 1;
                text_input::focus(raw_input_id())
            }

            Message::CloseTab(index) => {
                if self.tabs.len() > 1 {
                    if let Some(tab) = self.tabs.get(index) {
                        if let Some(session_id) = &tab.session_id {
                            let _ = self.pty_manager.close_session(session_id);
                        }
                    }
                    self.tabs.remove(index);
                    if self.active_tab >= self.tabs.len() {
                        self.active_tab = self.tabs.len() - 1;
                    }
                }
                Task::none()
            }

            Message::SelectTab(index) => {
                if index < self.tabs.len() {
                    self.active_tab = index;
                }
                text_input::focus(raw_input_id())
            }

            Message::CloseCurrentTab => {
                if self.tabs.len() > 1 {
                    if let Some(tab) = self.tabs.get(self.active_tab) {
                        if let Some(session_id) = &tab.session_id {
                            let _ = self.pty_manager.close_session(session_id);
                        }
                    }
                    self.tabs.remove(self.active_tab);
                    if self.active_tab >= self.tabs.len() {
                        self.active_tab = self.tabs.len() - 1;
                    }
                }
                text_input::focus(raw_input_id())
            }

            Message::NextTab => {
                if !self.tabs.is_empty() {
                    self.active_tab = (self.active_tab + 1) % self.tabs.len();
                }
                text_input::focus(raw_input_id())
            }

            Message::PrevTab => {
                if !self.tabs.is_empty() {
                    self.active_tab = if self.active_tab == 0 {
                        self.tabs.len() - 1
                    } else {
                        self.active_tab - 1
                    };
                }
                text_input::focus(raw_input_id())
            }

            Message::RawInput(input) => {
                // Send raw input directly to PTY (Raw mode)
                if let Some(tab) = self.tabs.get(self.active_tab) {
                    if let Some(session_id) = &tab.session_id {
                        let _ = self.pty_manager.write(session_id, input.as_bytes());
                    }
                }
                Task::none()
            }

            Message::RawInputChanged(new_input) => {
                // Handle text input in Raw mode (for IME/Korean support)
                if let Some(tab) = self.tabs.get_mut(self.active_tab) {
                    let old_len = tab.raw_input.chars().count();
                    let new_len = new_input.chars().count();

                    if let Some(session_id) = &tab.session_id {
                        if new_len > old_len {
                            // Characters were added - send only the new chars to PTY
                            let added: String = new_input.chars().skip(old_len).collect();
                            let _ = self.pty_manager.write(session_id, added.as_bytes());
                        } else if new_len < old_len {
                            // Characters were deleted - send backspace
                            let deleted_count = old_len - new_len;
                            for _ in 0..deleted_count {
                                let _ = self.pty_manager.write(session_id, &[0x7f]);
                                // Backspace
                            }
                        }
                    }
                    tab.raw_input = new_input;
                }
                Task::none()
            }

            Message::RawInputSubmit => {
                // Enter key in Raw mode - send newline and clear input
                if let Some(tab) = self.tabs.get_mut(self.active_tab) {
                    if let Some(session_id) = &tab.session_id {
                        let _ = self.pty_manager.write(session_id, b"\r");
                    }
                    tab.raw_input.clear();
                }
                text_input::focus(raw_input_id())
            }

            Message::KeyPressed(key, modifiers) => {
                // Handle Ctrl key signals
                if modifiers.control() {
                    match key.as_ref() {
                        Key::Character("c") => {
                            return self.update(Message::SendSignal(SignalType::Interrupt))
                        }
                        Key::Character("d") => {
                            return self.update(Message::SendSignal(SignalType::EOF))
                        }
                        Key::Character("z") => {
                            return self.update(Message::SendSignal(SignalType::Suspend))
                        }
                        _ => {}
                    }
                }

                // Handle keyboard shortcuts (Cmd key)
                if modifiers.command() {
                    match key.as_ref() {
                        Key::Character("t") => return self.update(Message::NewTab),
                        Key::Character("w") => return self.update(Message::CloseCurrentTab),
                        Key::Character("]") => return self.update(Message::NextTab),
                        Key::Character("[") => return self.update(Message::PrevTab),
                        Key::Character("1") => return self.update(Message::SelectTab(0)),
                        Key::Character("2") => return self.update(Message::SelectTab(1)),
                        Key::Character("3") => return self.update(Message::SelectTab(2)),
                        Key::Character("4") => return self.update(Message::SelectTab(3)),
                        Key::Character("5") => return self.update(Message::SelectTab(4)),
                        Key::Character("v") => {
                            return iced::clipboard::read().map(Message::ClipboardContent)
                        }
                        Key::Character("d") => return self.update(Message::ToggleDebugPanel), // Toggle debug panel
                        Key::Character("+") | Key::Character("=") => {
                            return self.update(Message::IncreaseFontSize)
                        }
                        Key::Character("-") => return self.update(Message::DecreaseFontSize),
                        Key::Character("0") => return self.update(Message::ResetFontSize),
                        _ => {}
                    }
                }

                // F12 to toggle debug panel (no modifier needed)
                if matches!(key.as_ref(), Key::Named(keyboard::key::Named::F12)) {
                    return self.update(Message::ToggleDebugPanel);
                }

                // Raw mode: send special keys directly to PTY
                // Regular characters are handled via RawInputChanged (for IME support)
                if !modifiers.command() {
                    // Check application cursor keys mode for arrow keys
                    let app_cursor_keys = self
                        .tabs
                        .get(self.active_tab)
                        .map(|tab| tab.screen.application_cursor_keys())
                        .unwrap_or(false);

                    let input = match key.as_ref() {
                        // Special/named keys only - NOT characters (handled by text_input for IME)
                        Key::Named(keyboard::key::Named::Escape) => Some("\x1b".to_string()),
                        // Arrow keys: switch between normal (\x1b[) and application (\x1bO) mode
                        Key::Named(keyboard::key::Named::ArrowUp) => {
                            Some(if app_cursor_keys { "\x1bOA" } else { "\x1b[A" }.to_string())
                        }
                        Key::Named(keyboard::key::Named::ArrowDown) => {
                            Some(if app_cursor_keys { "\x1bOB" } else { "\x1b[B" }.to_string())
                        }
                        Key::Named(keyboard::key::Named::ArrowRight) => {
                            Some(if app_cursor_keys { "\x1bOC" } else { "\x1b[C" }.to_string())
                        }
                        Key::Named(keyboard::key::Named::ArrowLeft) => {
                            Some(if app_cursor_keys { "\x1bOD" } else { "\x1b[D" }.to_string())
                        }
                        Key::Named(keyboard::key::Named::Home) => Some("\x1b[H".to_string()),
                        Key::Named(keyboard::key::Named::End) => Some("\x1b[F".to_string()),
                        Key::Named(keyboard::key::Named::PageUp) => Some("\x1b[5~".to_string()),
                        Key::Named(keyboard::key::Named::PageDown) => Some("\x1b[6~".to_string()),
                        Key::Named(keyboard::key::Named::Delete) => Some("\x1b[3~".to_string()),
                        Key::Named(keyboard::key::Named::Insert) => Some("\x1b[2~".to_string()),
                        Key::Named(keyboard::key::Named::Tab) => Some("\t".to_string()),
                        // Note: Enter, Backspace, Space are handled by text_input's on_submit and input changes
                        // Only handle them here as fallback if text_input doesn't capture them
                        _ => None,
                    };

                    if let Some(input_str) = input {
                        return self.update(Message::RawInput(input_str));
                    }
                }

                Task::none()
            }

            Message::SendSignal(signal_type) => {
                // Send signal to active PTY session
                if let Some(tab) = self.tabs.get(self.active_tab) {
                    if let Some(session_id) = &tab.session_id {
                        let signal_byte = signal_type.as_byte();
                        let _ = self.pty_manager.write(session_id, &[signal_byte]);
                    }
                }
                Task::none()
            }

            Message::ClipboardContent(clipboard_opt) => {
                if let Some(content) = clipboard_opt {
                    if let Some(tab) = self.tabs.get_mut(self.active_tab) {
                        // Send clipboard content directly to PTY
                        if let Some(session_id) = &tab.session_id {
                            let _ = self.pty_manager.write(session_id, content.as_bytes());
                        }
                    }
                }
                Task::none()
            }

            Message::WindowResized { width, height } => {
                // Calculate terminal dimensions based on approximate character size
                // D2Coding at ~13px = roughly 8px width, 18px height per character
                let cols = ((width as f32 / 8.0).max(80.0)) as u16;
                let rows = ((height as f32 / 18.0).max(24.0)) as u16;

                // Resize all active PTY sessions and screen buffers
                for tab in &mut self.tabs {
                    if let Some(session_id) = &tab.session_id {
                        let _ = self.pty_manager.resize(session_id, rows, cols);
                    }
                    // Resize screen buffer
                    tab.screen.resize(cols as usize, rows as usize);
                }
                Task::none()
            }

            Message::ToggleDebugPanel => {
                self.debug_panel.toggle();
                Task::none()
            }

            Message::DebugPanelMessage(msg) => {
                self.debug_panel.update(msg);
                Task::none()
            }

            Message::IncreaseFontSize => {
                self.font_size = (self.font_size + 1.0).min(24.0);
                Task::none()
            }

            Message::DecreaseFontSize => {
                self.font_size = (self.font_size - 1.0).max(8.0);
                Task::none()
            }

            Message::ResetFontSize => {
                self.font_size = 14.0;
                Task::none()
            }

            Message::Tick => {
                // Record frame for metrics
                self.debug_panel.metrics.record_frame();

                // Update input debug state
                if let Some(tab) = self.tabs.get(self.active_tab) {
                    self.debug_panel.input_state.raw_mode = tab.mode == TerminalMode::Raw;
                }

                // Cursor blinking (every 530ms, like Alacritty)
                const CURSOR_BLINK_INTERVAL_MS: u64 = 530;
                if self.last_cursor_blink.elapsed().as_millis() as u64 >= CURSOR_BLINK_INTERVAL_MS {
                    self.last_cursor_blink = Instant::now();
                    if let Some(tab) = self.tabs.get_mut(self.active_tab) {
                        tab.cursor_blink_on = !tab.cursor_blink_on;
                    }
                }

                // Auto-focus on raw input for IME support
                let focus_task = if self.startup_focus_count > 0 {
                    self.startup_focus_count -= 1;
                    text_input::focus(raw_input_id())
                } else {
                    Task::none()
                };

                // Poll PTY output only for active tab
                if let Some(tab) = self.tabs.get_mut(self.active_tab) {
                    if let Some(session_id) = &tab.session_id {
                        if let Ok(data) = self.pty_manager.read(session_id) {
                            if !data.is_empty() {
                                // Update PTY activity timestamp for dynamic tick optimization
                                self.last_pty_activity = Instant::now();

                                // Record PTY read metrics
                                self.debug_panel.metrics.record_pty_read(data.len());

                                // Process bytes through VTE parser
                                tab.screen.process(&data);

                                // Convert screen buffer to parsed line cache for rendering
                                let all_lines = tab.screen.get_all_lines();
                                tab.parsed_line_cache = all_lines
                                    .iter()
                                    .map(|cells| cells_to_styled_spans(cells))
                                    .collect();

                                // Increment content version for canvas cache invalidation
                                tab.content_version += 1;

                                // Auto-scroll to bottom
                                tab.canvas_state
                                    .scroll_to_bottom(tab.parsed_line_cache.len(), self.font_size);
                            }
                        }
                    }
                }
                focus_task
            }
        }
    }

    fn view(&self) -> Element<Message> {
        if self.tabs.is_empty() {
            return container(text("No terminal open").color(theme::TEXT_PRIMARY))
                .width(Length::Fill)
                .height(Length::Fill)
                .center_x(Length::Fill)
                .center_y(Length::Fill)
                .style(theme::primary_background_style)
                .into();
        }

        let tab_bar = self.view_tab_bar();
        let content = self.view_terminal_content();

        // Main Layout
        let terminal_area = column![
            container(tab_bar)
                .padding([10, 16])
                .width(Length::Fill)
                .style(|_| container::Style {
                    background: Some(theme::BG_PRIMARY.into()),
                    border: Border {
                        color: theme::BORDER,
                        width: 1.0,
                        radius: 0.0.into(),
                    },
                    ..Default::default()
                }),
            container(content)
                .width(Length::Fill)
                .height(Length::Fill)
                .style(|_| container::Style {
                    background: Some(theme::BG_SECONDARY.into()),
                    ..Default::default()
                })
        ]
        .width(Length::Fill);

        // Main content with optional debug panel
        let main_content: Element<Message> = if self.debug_panel.visible {
            let debug_panel_view: Element<Message> = self.debug_panel.view();
            row![terminal_area, debug_panel_view]
                .width(Length::Fill)
                .height(Length::Fill)
                .into()
        } else {
            terminal_area.height(Length::Fill).into()
        };

        container(main_content)
            .width(Length::Fill)
            .height(Length::Fill)
            .style(theme::primary_background_style)
            .into()
    }

    /// Render the tab bar with all tabs and new tab button
    fn view_tab_bar(&self) -> Element<Message> {
        let mut tab_elements = Vec::with_capacity(self.tabs.len());
        for (i, _) in self.tabs.iter().enumerate() {
            let is_active = i == self.active_tab;
            let label = format!("Terminal {}", i + 1);
            let can_close = self.tabs.len() > 1;

            let icon_color = if is_active {
                theme::TAB_ACTIVE
            } else {
                theme::TEXT_MUTED
            };
            let label_color = if is_active {
                theme::TEXT_PRIMARY
            } else {
                theme::TEXT_SECONDARY
            };

            // Tab label button (clickable to select)
            let tab_label_button = button(
                row![
                    text("▶").size(11).color(icon_color),
                    Space::with_width(8),
                    text(label.clone()).size(13).color(label_color)
                ]
                .align_y(Alignment::Center),
            )
            .padding([8, 12])
            .style(move |_, status| {
                let bg = match status {
                    button::Status::Hovered => {
                        if is_active {
                            theme::BG_SECONDARY
                        } else {
                            theme::BG_BLOCK_HOVER
                        }
                    }
                    _ => {
                        if is_active {
                            theme::BG_SECONDARY
                        } else {
                            theme::BG_PRIMARY
                        }
                    }
                };
                button::Style {
                    background: Some(bg.into()),
                    text_color: theme::TEXT_PRIMARY,
                    border: Border {
                        color: Color::TRANSPARENT,
                        width: 0.0,
                        radius: iced::border::Radius {
                            top_left: 6.0,
                            top_right: 0.0,
                            bottom_left: 0.0,
                            bottom_right: 0.0,
                        },
                    },
                    ..Default::default()
                }
            })
            .on_press(Message::SelectTab(i));

            // Close button (separate, clickable to close)
            let close_button = button(text("×").size(14))
                .padding([8, 10])
                .style(move |_, status| {
                    let (bg, text_color) = match status {
                        button::Status::Hovered => (theme::BG_BLOCK_HOVER, theme::ACCENT_RED),
                        _ => {
                            let bg = if is_active {
                                theme::BG_SECONDARY
                            } else {
                                theme::BG_PRIMARY
                            };
                            (bg, theme::TEXT_MUTED)
                        }
                    };
                    button::Style {
                        background: Some(bg.into()),
                        text_color,
                        border: Border {
                            color: Color::TRANSPARENT,
                            width: 0.0,
                            radius: iced::border::Radius {
                                top_left: 0.0,
                                top_right: 6.0,
                                bottom_left: 0.0,
                                bottom_right: 0.0,
                            },
                        },
                        ..Default::default()
                    }
                })
                .on_press_maybe(if can_close {
                    Some(Message::CloseTab(i))
                } else {
                    None
                });

            // Tab content with accent line
            let tab_content = column![
                row![tab_label_button, close_button],
                // Active tab bottom accent line
                container(Space::with_height(0))
                    .width(Length::Fill)
                    .height(2)
                    .style(move |_| container::Style {
                        background: if is_active {
                            Some(theme::TAB_ACTIVE.into())
                        } else {
                            None
                        },
                        ..Default::default()
                    })
            ];

            tab_elements.push(container(tab_content).into());
        }

        row(tab_elements)
            .spacing(2)
            .push(Space::with_width(8))
            .push(
                button(text("+").size(16).color(theme::TEXT_SECONDARY))
                    .padding([8, 14])
                    .style(|_, status| {
                        let bg = match status {
                            button::Status::Hovered => theme::BG_BLOCK_HOVER,
                            _ => theme::BG_BLOCK,
                        };
                        button::Style {
                            background: Some(bg.into()),
                            text_color: theme::TEXT_SECONDARY,
                            border: Border {
                                radius: 6.0.into(),
                                ..Default::default()
                            },
                            ..Default::default()
                        }
                    })
                    .on_press(Message::NewTab),
            )
            .into()
    }

    /// Render the terminal content area (output + input + status bar)
    fn view_terminal_content(&self) -> Element<Message> {
        if let Some(tab) = self.tabs.get(self.active_tab) {
            // Full Streaming Terminal
            let terminal_output = self.render_raw_terminal(&tab.parsed_line_cache);

            // Hidden Input (for IME/Korean support)
            // Note: We use a minimal-height container instead of size(0) to avoid cosmic-text crash
            let raw_input_field: Element<Message> = container(
                text_input("", &tab.raw_input)
                    .id(raw_input_id())
                    .on_input(Message::RawInputChanged)
                    .on_submit(Message::RawInputSubmit)
                    .size(1) // Minimum size to avoid crash
                    .style(|_theme, _status| text_input::Style {
                        background: Color::TRANSPARENT.into(),
                        border: Border::default(),
                        icon: Color::TRANSPARENT,
                        placeholder: Color::TRANSPARENT,
                        value: Color::TRANSPARENT,
                        selection: Color::TRANSPARENT,
                    }),
            )
            .height(Length::Fixed(1.0)) // Minimal height
            .into();

            let status_bar = self.view_status_bar();

            column![
                container(
                    column![
                        terminal_output,
                        raw_input_field // Hidden at bottom for IME
                    ]
                    .width(Length::Fill)
                    .height(Length::Fill)
                )
                .padding([16, 12]) // Top padding for spacing from tab bar
                .width(Length::Fill)
                .height(Length::Fill)
                .style(|_| container::Style {
                    background: Some(theme::BG_SECONDARY.into()),
                    ..Default::default()
                }),
                status_bar
            ]
            .width(Length::Fill)
            .height(Length::Fill)
            .into()
        } else {
            column![text("No terminal open").color(theme::TEXT_PRIMARY)].into()
        }
    }

    /// Render the status bar with shell name, mode, and shortcuts
    fn view_status_bar(&self) -> Element<Message> {
        let shell_name = self.get_shell_name();
        let mode_indicator = text("STREAMING").size(11).color(theme::ACCENT_GREEN);
        let tab_info = format!("Tab {} of {}", self.active_tab + 1, self.tabs.len());

        let status_left = row![
            text(shell_name).size(12).color(theme::TEXT_MUTED),
            Space::with_width(12),
            mode_indicator
        ];

        let status_center = text(tab_info).size(12).color(theme::TEXT_MUTED);

        let status_right = text("⌘T New | ⌘W Close | ⌘D Debug")
            .size(12)
            .color(theme::TEXT_MUTED);

        container(
            row![
                status_left,
                Space::with_width(Length::Fill),
                status_center,
                Space::with_width(Length::Fill),
                status_right
            ]
            .align_y(Alignment::Center)
            .width(Length::Fill),
        )
        .padding([4, 12])
        .width(Length::Fill)
        .style(theme::status_bar_style)
        .into()
    }

    /// Render raw terminal output (for Raw mode)
    /// Uses Canvas for virtual scrolling and hardware acceleration
    fn render_raw_terminal<'a>(&self, parsed_cache: &'a [Vec<StyledSpan>]) -> Element<'a, Message> {
        use iced::widget::canvas;

        let tab = &self.tabs[self.active_tab];
        let (cursor_row, cursor_col) = tab.screen.cursor_position();

        // Create cursor state
        let cursor = CursorState {
            row: cursor_row,
            col: cursor_col,
            style: CursorStyle::Block,
            visible: tab.screen.cursor_visible(),
            blink_on: tab.cursor_blink_on,
        };

        // Create terminal canvas with all lines (virtual scrolling will handle visibility)
        let terminal_canvas = TerminalCanvas::new(
            parsed_cache,
            tab.content_version,
            theme::TEXT_PRIMARY,
            MONO_FONT,
        )
        .with_cursor(cursor)
        .with_font_size(self.font_size);

        canvas(terminal_canvas)
            .width(Length::Fill)
            .height(Length::Fill)
            .into()
    }

    fn subscription(&self) -> Subscription<Message> {
        // Dynamic tick interval based on PTY activity
        // - Recent activity (< 500ms): 16ms (60fps) for smooth updates
        // - Medium activity (< 2s): 50ms (20fps) for responsiveness
        // - Idle: 200ms (5fps) to save CPU
        let elapsed_since_activity = self.last_pty_activity.elapsed();
        let tick_interval = if elapsed_since_activity < Duration::from_millis(500) {
            Duration::from_millis(16) // 60fps
        } else if elapsed_since_activity < Duration::from_secs(2) {
            Duration::from_millis(50) // 20fps
        } else {
            Duration::from_millis(200) // 5fps
        };

        let timer = iced::time::every(tick_interval).map(|_| Message::Tick);

        let keyboard =
            keyboard::on_key_press(|key, modifiers| Some(Message::KeyPressed(key, modifiers)));

        // Listen for window resize events
        let window_events = iced::event::listen_with(|event, _status, _id| {
            if let iced::Event::Window(iced::window::Event::Resized(size)) = event {
                Some(Message::WindowResized {
                    width: size.width as u32,
                    height: size.height as u32,
                })
            } else {
                None
            }
        });

        Subscription::batch([timer, keyboard, window_events])
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Duration;

    // ========== Tab Management Tests ==========

    /// Create a mock AgTerm instance for testing (without PTY)
    fn create_test_app() -> AgTerm {
        let pty_manager = Arc::new(PtyManager::new());

        let tab = TerminalTab {
            id: 0,
            session_id: None, // No actual PTY for tests
            raw_input: String::new(),
            input: String::new(),
            cwd: "/test/path".to_string(),
            error_message: None,
            history: Vec::new(),
            history_index: None,
            history_temp_input: String::new(),
            mode: TerminalMode::Raw,
            parsed_line_cache: Vec::new(),
            canvas_state: TerminalCanvasState::new(),
            content_version: 0,
            screen: TerminalScreen::new(80, 24),
            cursor_blink_on: true,
        };

        AgTerm {
            tabs: vec![tab],
            active_tab: 0,
            pty_manager,
            next_tab_id: 1,
            startup_focus_count: 0,
            debug_panel: DebugPanel::new(),
            last_pty_activity: Instant::now(),
            last_cursor_blink: Instant::now(),
            font_size: 14.0,
        }
    }

    #[test]
    fn test_initial_state() {
        let app = create_test_app();
        assert_eq!(app.tabs.len(), 1);
        assert_eq!(app.active_tab, 0);
        assert_eq!(app.tabs[0].cwd, "/test/path");
    }

    #[test]
    fn test_new_tab() {
        let mut app = create_test_app();
        let initial_count = app.tabs.len();

        let _ = app.update(Message::NewTab);

        assert_eq!(app.tabs.len(), initial_count + 1);
        assert_eq!(app.active_tab, initial_count); // Should switch to new tab
    }

    #[test]
    fn test_close_current_tab_with_multiple_tabs() {
        let mut app = create_test_app();
        let _ = app.update(Message::NewTab); // Now we have 2 tabs
        assert_eq!(app.tabs.len(), 2);

        let _ = app.update(Message::CloseCurrentTab);

        assert_eq!(app.tabs.len(), 1);
    }

    #[test]
    fn test_close_tab_preserves_minimum() {
        let mut app = create_test_app();
        assert_eq!(app.tabs.len(), 1);

        let _ = app.update(Message::CloseCurrentTab);

        // Should not close the last tab
        assert_eq!(app.tabs.len(), 1);
    }

    #[test]
    fn test_select_tab() {
        let mut app = create_test_app();
        let _ = app.update(Message::NewTab);
        let _ = app.update(Message::NewTab);
        assert_eq!(app.tabs.len(), 3);

        let _ = app.update(Message::SelectTab(0));
        assert_eq!(app.active_tab, 0);

        let _ = app.update(Message::SelectTab(2));
        assert_eq!(app.active_tab, 2);
    }

    #[test]
    fn test_select_invalid_tab() {
        let mut app = create_test_app();
        let _ = app.update(Message::SelectTab(999));

        // Should not change active tab if index is invalid
        assert_eq!(app.active_tab, 0);
    }

    #[test]
    fn test_next_tab_cycling() {
        let mut app = create_test_app();
        let _ = app.update(Message::NewTab);
        let _ = app.update(Message::NewTab);
        // 3 tabs: 0, 1, 2; active = 2

        let _ = app.update(Message::NextTab);
        assert_eq!(app.active_tab, 0); // Should cycle back to 0
    }

    #[test]
    fn test_prev_tab_cycling() {
        let mut app = create_test_app();
        let _ = app.update(Message::NewTab);
        let _ = app.update(Message::NewTab);
        let _ = app.update(Message::SelectTab(0));

        let _ = app.update(Message::PrevTab);
        assert_eq!(app.active_tab, 2); // Should cycle to last tab
    }

    // ========== Theme Tests ==========

    #[test]
    fn test_theme_colors_defined() {
        // Verify all theme colors are accessible
        let _ = theme::BG_PRIMARY;
        let _ = theme::BG_SECONDARY;
        let _ = theme::BG_BLOCK;
        let _ = theme::BG_BLOCK_HOVER;
        let _ = theme::BG_INPUT;
        let _ = theme::TEXT_PRIMARY;
        let _ = theme::TEXT_SECONDARY;
        let _ = theme::TEXT_MUTED;
        let _ = theme::ACCENT_BLUE;
        let _ = theme::ACCENT_GREEN;
        let _ = theme::ACCENT_YELLOW;
        let _ = theme::ACCENT_RED;
        let _ = theme::BORDER;
        let _ = theme::TAB_ACTIVE;
        let _ = theme::PROMPT;
    }

    // ========== Integration Tests (with actual PTY) ==========

    #[test]
    #[cfg(unix)] // PTY tests only work on Unix
    fn test_pty_session_creation() {
        let pty_manager = PtyManager::new();
        let result = pty_manager.create_session(24, 80);

        assert!(result.is_ok(), "PTY session should be created successfully");

        let session_id = result.unwrap();
        let close_result = pty_manager.close_session(&session_id);
        assert!(close_result.is_ok());
    }

    #[test]
    #[cfg(unix)]
    fn test_pty_write_read() {
        let pty_manager = PtyManager::new();
        let session_id = pty_manager.create_session(24, 80).unwrap();

        // Write a simple command
        let write_result = pty_manager.write(&session_id, b"echo test\n");
        assert!(write_result.is_ok());

        // Give PTY time to process
        std::thread::sleep(Duration::from_millis(200));

        // Read output
        let read_result = pty_manager.read(&session_id);
        assert!(read_result.is_ok());

        let _ = pty_manager.close_session(&session_id);
    }
}
